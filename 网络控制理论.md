```matlab 
function [E] = MIN_CONTROL_ENERGY(A, WcI, x0, xf, T,normalize)
% Computes minimum control energy for state transition.
% A: System adjacency matrix: n x n
% x0: Initial state
% xf: Final state
% T: Control horizon
% 
% Outputs
% E: Minimum control energy
if ~exist('normalize','var')
	normalize = true;
end

% Normalize
if normalize
	A = (A / (max(eig(A)))) - eye(length(A));
	disp(['After normalization, max eigenvalue of A is ',num2str(max(eig(A)))])
end
% State transition to achieve
Phi = expm(A*T)*x0 - xf;
% Energy
E = sum((WcI*Phi).*Phi);
end
```



```matlab
function [ x, u, n_err ] = MIN_ENG_CONT(A, T, B, x0, xf, nor)
% Computes minimum control energy for state transition.
% A: System adjacency matrix:         N x N
% B: Control input matrix:            N x k
% x0: Initial state:                  N x 1
% xf: Final state:                    N x 1
% T: Control horizon                  1 x 1
% nor: normalization                  boolean
% 
% Outputs
% x: State Trajectory
% u: Control Input

% Normalize
if nor == 1
    A = A/(eigs(A,1)+1) - eye(size(A));
end

% System Size
n = size(A,1);

% Compute Matrix Exponential
AT = [A              -.5*(B*B');...
      zeros(size(A)) -A'];
E = expm(AT*T);

% Compute Costate Initial Condition
E12 = E(1:n,[1:n]+n);
E11 = E(1:n,1:n);
p0 = pinv(E12)*(xf - E11*x0);

% Compute Costate Initial Condition Error Induced by Inverse
n_err = norm(E12*p0 - (xf - E11*x0));

% Prepare Simulation
nStep=1000;
t = linspace(0,T,nStep+1);

v0 = [x0; p0];                      % Initial Condition
v = zeros(2*n,length(t));           % Trajectory
Et = expm(AT*T/(length(t)-1));
v(:,1) = v0;

% Simulate State and Costate Trajectories
for i = 2:length(t)
    v(:,i) = Et*v(:,i-1);
end
x = v(1:n,:);
u = -0.5*B'*v([1:n]+n,:);

disp([n_err, norm(x(:,end)-xf)]);

% transpose to be similar to opt_eng_cont
u = u';
x = x';

end

E = sum(sum(u.^2))*T/1001; % integrate over inputs
```

###`MIN_ENG_CONT` 函数

这两个方法的本质目的是一样的：求解最小控制能量，但它们所依赖的数学工具和求解步骤有所不同。一个是通过解Lyapunov方程和Gram矩阵来求解，另一个则是通过状态转移矩阵和Gram矩阵的逆来计算。根据不同的系统模型和需求，可以选择合适的方法来进行最小控制能量的计算。

1.**最小控制能量问题**：
最小控制能量问题通常可以通过解一个二次优化问题来描述，其目标是最小化控制输入的能量，并确保系统从初始状态 x0 转移到目标状态 xf在给定时间 T 内。能量的最小化通常是一个二次型目标函数，表示为：
$$
E=\int_0^T\mu(t)^TR\mu(t)dt
$$
2.**代价态和状态的演化**：
系统状态 x(t) 和代价态（p）的演化可以由一组线性微分方程描述:
$$
\frac{dx}{dt}=Ax(t)+B\mu(t)\\\frac{dp}{dt}=-A^Tp(t)-Qx(t)
$$
3.**控制输入最优解**：
$$
\mu(t)=-\frac{1}{2}B^Tp(t)
$$
4.**p(t)更新**

$$\begin{bmatrix}\dot{x}(t) \\\dot{p}(t)\end{bmatrix}=\begin{bmatrix}A & -Q \\B & -A^T\end{bmatrix}\begin{bmatrix}x(t) \\p(t)\end{bmatrix}+\begin{bmatrix}0 \\R\end{bmatrix}u(t)$$

$$\mathbf{A}_T = \begin{bmatrix} \mathbf{A} & 0 \\-0.5 \mathbf{B} \mathbf{B}^T & -\mathbf{A} \end{bmatrix}$$

首先，`Et` 是矩阵指数的一个应用，表示系统在离散时间步长 $$\frac{T}{\text{length}(t)-1}$$上的转移矩阵。

$$E_t = \exp\left(\frac{\mathbf{A}_T T}{\text{length}(t)-1}\right)$$

我们处理的是一个状态空间的扩展模型，其中状态$$x(t)$$和共轭状态 $$p(t)$$ 联合演化。为了方便，设定:$$v(t) = \begin{bmatrix} x(t) \\ p(t) \end{bmatrix}$$

状态和共轭状态的更新可以写为:

- **状态 \( x(t) \) 的更新：**

$$x(t_i) = E_{11} x(t_{i-1}) + E_{12} p(t_{i-1})$$

- **共轭状态 \( p(t) \) 的更新：**

$$p(t_i) = E_{21} x(t_{i-1}) + E_{22} p(t_{i-1})$$



## WcIJ解法

```matlab
function Wm = gram_lyaplov(A,B,T)
%   Calculate gram matrix by Lyaplov equation (controllable system)
%
%   Solve Lyaplov equation: AW + WA^T +BB^T = 0
%
%   Inputs:     A,     N-by-N matrix, system matrix
%               B,     N-by-M matrix, control matrix with M control nodes
%               T,     Constant, control time
%
%   Output:     Wm,    N-by-M matrix, system gram matrix
    [row,col] = size(A);
    C = eye(row,col);
    D = zeros(size(B));
    sys =  ss(A,B,C,D); % Build a linear systems
    opt = gramOptions('TimeInterVals',[0,T]); % Control during finite time
    Wm = gram(sys,'c',opt);
end
```

```matlab
function [WcI] = GRAMIAN(A, T, normalize)
% Computes minimum control energy for state transition.
% A: System adjacency matrix: n x n
% x0: Initial state
% xf: Final state
% T: Control horizon
% 
% Outputs
% E: Minimum control energy
if ~exist('normalize','var')
	normalize = true;
end

% Normalize
if normalize
	A = (A / (max(eig(A)))) - eye(length(A));
	disp(['After normalization, max eigenvalue of A is ',num2str(max(eig(A)))])
end
% Gramian
Wc = integral(@(t)expm((A+A')*t), 0, T, 'ArrayValued', 1);
% Inverse
WcI = Wc^-1;
```

###1.`gram_lyaplov` 函数

此函数的目的是通过 Lyapunov 方程计算系统的 Gram 矩阵。Lyapunov 方程通常用于线性系统的控制理论中，描述了系统的可控性和稳定性。在此函数中，采用的是 Lyapunov 方程的解：
$$
AW+WA^T+BB^T=0
$$
**sys = ss(A,B,C,D)**：构建一个线性系统模型，`ss` 是 MATLAB 中的命令，用于表示状态空间模型。

**opt = gramOptions('TimeInterVals',[0,T])**：设置 Gram 矩阵计算的时间区间为 [0,T][0, T][0,T]。

**Wm = gram(sys,'c',opt)**：计算控制 Gram 矩阵。`gram` 函数是用来求解控制系统的 Gram 矩阵的，其中 `'c'` 表示计算可控 Gram 矩阵。

### 2.`GRAMIAN` 函数

该函数的目的是计算最小控制能量的 Gram 矩阵。它通过时间积分计算了一个系统在控制时的 **控制能量**，并返回控制 Gram 矩阵的逆矩阵。控制 Gram 矩阵是一个衡量系统控制性的矩阵。对于一个线性时不变系统，控制 Gram 矩阵 $$W_c$$定义为:
$$
W_c=\int_0^Te^{A(t-\tau)}BB^Te^{A(t-\tau)}d\tau
$$
